// This file is auto-generated by organjsm tangle. Do not edit directly.
// Source: index.org

// [[file:index.org::726]]
module AgentRex.Stream

open FSharp.Control

/// <summary>
/// Creates a stream that emits a single value and then completes.
/// </summary>
let just (value: 'T) : AsyncSeq<'T> =
  asyncSeq {
    yield value
  }

/// <summary>
/// Alias for just.
/// </summary>
let of' = just
// unnamed ends here

// [[file:index.org::1151]]
/// <summary>
/// Creates a stream from an async computation.
/// When the computation completes, the stream emits the value and finishes.
/// </summary>
let fromAsync (computation: Async<'T>) : AsyncSeq<'T> =
  asyncSeq {
    let! value = computation
    yield value
  }

/// <summary>
/// Creates a stream from a Task.
/// </summary>
let fromTask (task: System.Threading.Tasks.Task<'T>) : AsyncSeq<'T> =
  asyncSeq {
    let! value = Async.AwaitTask task
    yield value
  }
// unnamed ends here

// [[file:index.org::1492]]
/// <summary>
/// Creates a stream from a sequence.
/// Emits each value from the sequence in order.
/// </summary>
let fromSeq (source: seq<'T>) : AsyncSeq<'T> =
  AsyncSeq.ofSeq source

/// <summary>
/// Creates a stream from a list.
/// </summary>
let fromList (source: 'T list) : AsyncSeq<'T> =
  AsyncSeq.ofSeq source

/// <summary>
/// Creates a stream from an array.
/// </summary>
let fromArray (source: 'T[]) : AsyncSeq<'T> =
  AsyncSeq.ofSeq source
// unnamed ends here

// [[file:index.org::1824]]
/// <summary>
/// Creates a stream that emits unit at regular intervals.
/// To give it a value, combine it with constant.
/// </summary>
let periodic (intervalMs: int) : AsyncSeq<unit> =
  asyncSeq {
    while true do
      yield ()
      do! Async.Sleep intervalMs
  }
// unnamed ends here

// [[file:index.org::2059]]
/// <summary>
/// Creates a stream that immediately completes without emitting any values.
/// </summary>
let empty<'T> () : AsyncSeq<'T> =
  AsyncSeq.empty
// unnamed ends here

// [[file:index.org::2302]]
/// <summary>
/// Creates a stream that never emits any values and never completes.
/// </summary>
let never<'T> () : AsyncSeq<'T> =
  asyncSeq {
    // Async computation that never completes
    do! Async.Sleep(System.Threading.Timeout.Infinite)
  }
// unnamed ends here

// [[file:index.org::2600]]
/// <summary>
/// Creates a stream that emits an infinite sequence by repeatedly applying a function.
/// </summary>
let iterate (seed: 'T) (fn: 'T -> 'T) : AsyncSeq<'T> =
  AsyncSeq.unfoldAsync (fun state ->
    async {
      return Some(state, fn state)
    }
  ) seed
// unnamed ends here

// [[file:index.org::3028]]
/// <summary>
/// Result of an unfold step.
/// </summary>
type UnfoldResult<'T, 'S> = {
  Value: 'T
  NextSeed: 'S
  Done: bool
}

/// <summary>
/// Creates a stream by unfolding a seed value.
/// The function returns an object containing the next value, next seed, and done flag.
/// </summary>
let unfold (fn: 'S -> UnfoldResult<'T, 'S>) (seed: 'S) : AsyncSeq<'T> =
  asyncSeq {
    let mutable currentSeed = seed
    let mutable continue' = true
    while continue' do
      let result = fn currentSeed
      if result.Done then
        continue' <- false
      else
        yield result.Value
        currentSeed <- result.NextSeed
  }
// unnamed ends here

// [[file:index.org::3370]]
/// <summary>
/// Prepends a value to the beginning of a stream.
/// </summary>
let startWith (value: 'T) (stream: AsyncSeq<'T>) : AsyncSeq<'T> =
  asyncSeq {
    yield value
    yield! stream
  }
// unnamed ends here

// [[file:index.org::3731]]
/// <summary>
/// Concatenates two streams into a single stream.
/// </summary>
let concat2 (s1: AsyncSeq<'T>) (s2: AsyncSeq<'T>) : AsyncSeq<'T> =
  asyncSeq {
    yield! s1
    yield! s2
  }

/// <summary>
/// Concatenates multiple streams into a single stream.
/// </summary>
let concat (streams: AsyncSeq<'T> list) : AsyncSeq<'T> =
  asyncSeq {
    for stream in streams do
      yield! stream
  }
// unnamed ends here

// [[file:index.org::4614]]
/// <summary>
/// Transforms each value emitted by a stream using a provided function.
/// </summary>
let map (fn: 'T -> 'U) (source: AsyncSeq<'T>) : AsyncSeq<'U> =
  AsyncSeq.map fn source

/// <summary>
/// Transforms each value using an async function.
/// </summary>
let mapAsync (fn: 'T -> Async<'U>) (source: AsyncSeq<'T>) : AsyncSeq<'U> =
  AsyncSeq.mapAsync fn source
// unnamed ends here

// [[file:index.org::4973]]
/// <summary>
/// Emits a constant value for each item in the source stream.
/// </summary>
let constant (value: 'U) (source: AsyncSeq<'T>) : AsyncSeq<'U> =
  AsyncSeq.map (fun _ -> value) source
// unnamed ends here

// [[file:index.org::5345]]
/// <summary>
/// Accumulates values using an accumulator function, emitting each intermediate result.
/// Yields the seed first, then each accumulated value.
/// </summary>
let scan (folder: 'State -> 'T -> 'State) (state: 'State) (source: AsyncSeq<'T>) : AsyncSeq<'State> =
  asyncSeq {
    yield state
    let mutable acc = state
    for value in source do
      acc <- folder acc value
      yield acc
  }

/// <summary>
/// Scan with async accumulator.
/// </summary>
let scanAsync (folder: 'State -> 'T -> Async<'State>) (state: 'State) (source: AsyncSeq<'T>) : AsyncSeq<'State> =
  asyncSeq {
    yield state
    let mutable acc = state
    for value in source do
      let! newAcc = folder acc value
      acc <- newAcc
      yield acc
  }
// unnamed ends here

// [[file:index.org::5727]]
/// <summary>
/// Performs side effects for each value without modifying them.
/// </summary>
let tap (sideEffect: 'T -> unit) (stream: AsyncSeq<'T>) : AsyncSeq<'T> =
  asyncSeq {
    for item in stream do
      sideEffect item
      yield item
  }
// unnamed ends here

// [[file:index.org::6051]]
/// <summary>
/// Performs side effects for each value, awaiting completion before yielding.
/// </summary>
let awaitTap (sideEffect: 'T -> Async<unit>) (stream: AsyncSeq<'T>) : AsyncSeq<'T> =
  asyncSeq {
    for item in stream do
      do! sideEffect item
      yield item
  }
// unnamed ends here

// [[file:index.org::6426]]
/// <summary>
/// Continues a stream with another stream once the first completes.
/// </summary>
let continueWith (f: unit -> AsyncSeq<'T>) (stream: AsyncSeq<'T>) : AsyncSeq<'T> =
  asyncSeq {
    yield! stream
    yield! f()
  }
// unnamed ends here

// [[file:index.org::6739]]
/// <summary>
/// Flattens a stream of streams by concatenating them into a single stream.
/// </summary>
let concatAll (streamOfStreams: AsyncSeq<AsyncSeq<'T>>) : AsyncSeq<'T> =
  asyncSeq {
    for innerStream in streamOfStreams do
      yield! innerStream
  }
// unnamed ends here

// [[file:index.org::7081]]
/// <summary>
/// Maps each value to a stream and concatenates the results in order.
/// </summary>
let concatMap (f: 'T -> AsyncSeq<'U>) (stream: AsyncSeq<'T>) : AsyncSeq<'U> =
  asyncSeq {
    for item in stream do
      yield! f item
  }
// unnamed ends here

// [[file:index.org::7497]]
/// <summary>
/// Filters values emitted by a stream based on a provided predicate function.
/// </summary>
let filter (predicate: 'T -> bool) (source: AsyncSeq<'T>) : AsyncSeq<'T> =
    AsyncSeq.filter predicate source

/// <summary>
/// Filters with an async predicate.
/// </summary>
let filterAsync (predicate: 'T -> Async<bool>) (source: AsyncSeq<'T>) : AsyncSeq<'T> =
    AsyncSeq.filterAsync predicate source
// unnamed ends here

// [[file:index.org::8075]]
/// <summary>
/// Filters out consecutive duplicate values from a stream.
/// </summary>
let skipRepeats (stream: AsyncSeq<'T>) : AsyncSeq<'T> =
  asyncSeq {
    let mutable first = true
    let mutable lastValue = Unchecked.defaultof<'T>
    for item in stream do
      if first || not (obj.Equals(item, lastValue)) then
        yield item
        lastValue <- item
        first <- false
  }

/// <summary>
/// Filters out consecutive duplicates using a custom equality function.
/// </summary>
let skipRepeatsWith (equals: 'T -> 'T -> bool) (stream: AsyncSeq<'T>) : AsyncSeq<'T> =
  asyncSeq {
    let mutable first = true
    let mutable lastValue = Unchecked.defaultof<'T>
    for item in stream do
      if first || not (equals item lastValue) then
        yield item
        lastValue <- item
        first <- false
  }
// unnamed ends here

// [[file:index.org::8493]]
/// <summary>
/// Takes only the first n values from a stream.
/// </summary>
let take (n: int) (source: AsyncSeq<'T>) : AsyncSeq<'T> =
  AsyncSeq.take n source
// unnamed ends here

// [[file:index.org::8828]]
/// <summary>
/// Skips the first n values from a stream.
/// </summary>
let skip (n: int) (source: AsyncSeq<'T>) : AsyncSeq<'T> =
  AsyncSeq.skip n source
// unnamed ends here

// [[file:index.org::9208]]
/// <summary>
/// Emits values from index start to end (exclusive).
/// </summary>
let slice (start: int) (end': int) (stream: AsyncSeq<'T>) : AsyncSeq<'T> =
  asyncSeq {
    let mutable index = 0
    for item in stream do
      if index >= start && index < end' then
        yield item
      index <- index + 1
      if index >= end' then
        ()
  }
// unnamed ends here

// [[file:index.org::9605]]
/// <summary>
/// Takes values from a stream while the predicate returns true.
/// </summary>
let takeWhile (predicate: 'T -> bool) (stream: AsyncSeq<'T>) : AsyncSeq<'T> =
  AsyncSeq.takeWhile predicate stream
// unnamed ends here

// [[file:index.org::10002]]
/// <summary>
/// Skips values while the predicate returns true, then emits the rest.
/// </summary>
let skipWhile (predicate: 'T -> bool) (stream: AsyncSeq<'T>) : AsyncSeq<'T> =
  AsyncSeq.skipWhile predicate stream
// unnamed ends here

// [[file:index.org::10393]]
/// <summary>
/// Takes values until the predicate matches (matching value not emitted).
/// </summary>
let takeUntil (predicate: 'T -> bool) (stream: AsyncSeq<'T>) : AsyncSeq<'T> =
  stream |> AsyncSeq.takeWhile (fun item -> not (predicate item))
// unnamed ends here

// [[file:index.org::10822]]
/// <summary>
/// Delays each emission by the specified duration in milliseconds.
/// </summary>
let delayEach (delayMs: int) (source: AsyncSeq<'T>) : AsyncSeq<'T> =
  asyncSeq {
    for value in source do
      do! Async.Sleep delayMs
      yield value
  }
// unnamed ends here

// [[file:index.org::11316]]
open System.Threading
open System.Threading.Channels

/// <summary>
/// Only emits a value if no new values arrive within the specified duration.
/// Collects timestamped values then filters based on timing gaps.
/// </summary>
let debounceEach (durationMs: int) (source: AsyncSeq<'T>) : AsyncSeq<'T> =
  asyncSeq {
    // Collect all values with timestamps
    let timestamped = ResizeArray<struct (System.DateTime * 'T)>()
    for item in source do
      timestamped.Add(struct (System.DateTime.UtcNow, item))
    
    // Apply debounce logic: emit value only if followed by gap >= durationMs
    let duration = System.TimeSpan.FromMilliseconds(float durationMs)
    for i in 0 .. timestamped.Count - 1 do
      let struct (time, value) = timestamped.[i]
      let isLast = i = timestamped.Count - 1
      if isLast then
        yield value
      else
        let struct (nextTime, _) = timestamped.[i + 1]
        if nextTime - time >= duration then
          yield value
  }
// unnamed ends here

// [[file:index.org::11995]]
type ThrottleOptions = {
  Leading: bool
  Trailing: bool
}
with
  static member Default = { Leading = true; Trailing = true }
  static member LeadingOnly = { Leading = true; Trailing = false }
  static member TrailingOnly = { Leading = false; Trailing = true }

/// <summary>
/// Limits the rate of emissions with leading/trailing edge control.
/// </summary>
let throttleEach (windowMs: int) (options: ThrottleOptions) (source: AsyncSeq<'T>) : AsyncSeq<'T> =
  asyncSeq {
    let mutable lastEmitTime = System.DateTimeOffset.MinValue
    let mutable trailingValue = Unchecked.defaultof<'T>
    let mutable hasTrailing = false
    
    for item in source do
      let now = System.DateTimeOffset.UtcNow
      let elapsed = (now - lastEmitTime).TotalMilliseconds
      
      if elapsed >= float windowMs then
        if options.Leading then
          yield item
          lastEmitTime <- now
          hasTrailing <- false
        else
          trailingValue <- item
          hasTrailing <- true
      else
        trailingValue <- item
        hasTrailing <- true
    
    // Emit final trailing value if any
    if hasTrailing && options.Trailing then
      yield trailingValue
  }
// unnamed ends here

// [[file:index.org::12568]]
/// <summary>
/// Recovers from errors by switching to an alternative stream.
/// </summary>
let recoverWith (recoverFn: exn -> AsyncSeq<'T>) (source: AsyncSeq<'T>) : AsyncSeq<'T> =
  asyncSeq {
    let mutable error: exn option = None
    try
      for item in source do
        yield item
    with
    | e -> error <- Some e
    
    match error with
    | Some ex -> yield! recoverFn ex
    | None -> ()
  }
// unnamed ends here

// [[file:index.org::13049]]
/// <summary>
/// Creates a stream that immediately throws an error when consumed.
/// </summary>
let throwError<'T> (error: exn) : AsyncSeq<'T> =
  asyncSeq {
    raise error
  }
// unnamed ends here

// [[file:index.org::13708]]
type RetryOptions = {
  MaxAttempts: int
  DelayMs: int
  ShouldRetry: (exn -> int -> bool) option
}
with
  static member Default = { MaxAttempts = 3; DelayMs = 0; ShouldRetry = None }

/// <summary>
/// Retries a stream factory when it errors.
/// </summary>
let retry (options: RetryOptions) (streamFactory: unit -> AsyncSeq<'T>) : AsyncSeq<'T> =
  asyncSeq {
    let mutable attempt = 0
    let mutable success = false
    
    while not success do
      try
        for item in streamFactory() do
          yield item
        success <- true
      with
      | ex ->
          attempt <- attempt + 1
          let shouldRetry = 
            match options.ShouldRetry with
            | Some fn -> fn ex attempt
            | None -> true
          
          if attempt >= options.MaxAttempts || not shouldRetry then
            raise ex
          
          if options.DelayMs > 0 then
            do! Async.Sleep options.DelayMs
  }
// unnamed ends here

// [[file:index.org::14314]]
/// <summary>
/// Merges multiple streams into a single stream, emitting values as they arrive.
/// </summary>
let merge (sources: AsyncSeq<'T> list) : AsyncSeq<'T> =
  AsyncSeq.mergeAll sources

/// <summary>
/// Merges two streams into a single stream.
/// </summary>
let merge2 (source1: AsyncSeq<'T>) (source2: AsyncSeq<'T>) : AsyncSeq<'T> =
  AsyncSeq.mergeAll [source1; source2]
// unnamed ends here

// [[file:index.org::14697]]
/// <summary>
/// Flattens a stream of streams by merging them into a single stream.
/// Note: Collects all inner streams first, then merges them.
/// </summary>
let mergeAll (streamOfStreams: AsyncSeq<AsyncSeq<'T>>) : AsyncSeq<'T> =
  asyncSeq {
    let! streams = streamOfStreams |> AsyncSeq.toListAsync
    yield! AsyncSeq.mergeAll streams
  }
// unnamed ends here

// [[file:index.org::15136]]
/// <summary>
/// Maps each value to a stream and flattens the results.
/// Also known as chain or flatMap in some libraries.
/// </summary>
let chain (selector: 'T -> AsyncSeq<'U>) (source: AsyncSeq<'T>) : AsyncSeq<'U> =
  AsyncSeq.collect selector source

/// <summary>
/// Alias for chain.
/// </summary>
let flatMap (selector: 'T -> AsyncSeq<'U>) (source: AsyncSeq<'T>) : AsyncSeq<'U> =
  chain selector source
// unnamed ends here

// [[file:index.org::15624]]
/// <summary>
/// Maps each value to a stream, canceling the previous inner stream when a new value arrives.
/// Note: This is a simplified implementation using collect (similar to flatMap).
/// True switchMap with cancellation would require MailboxProcessor or other coordination.
/// </summary>
let switchMap (selector: 'T -> AsyncSeq<'U>) (source: AsyncSeq<'T>) : AsyncSeq<'U> =
  AsyncSeq.collect selector source
// unnamed ends here

// [[file:index.org::16059]]
/// <summary>
/// Combines two streams, emitting tuples of latest values whenever either emits.
/// Simplified implementation - full reactive combination requires complex coordination.
/// </summary>
let latest2 (source1: AsyncSeq<'T>) (source2: AsyncSeq<'U>) : AsyncSeq<'T * 'U> =
  asyncSeq {
    // Simplified: zips the streams instead of true latest behavior
    // True latest requires concurrent consumption with state tracking
    for v1 in source1 do
      for v2 in source2 do
        yield (v1, v2)
  }
// unnamed ends here

// [[file:index.org::16331]]
/// <summary>
/// Applies the latest function to the latest value.
/// </summary>
let applyLatest (fnStream: AsyncSeq<'T -> 'U>) (valueStream: AsyncSeq<'T>) : AsyncSeq<'U> =
  latest2 fnStream valueStream
  |> AsyncSeq.map (fun (fn, value) -> fn value)
// unnamed ends here

// [[file:index.org::16707]]
/// <summary>
/// Emits values from source until stop stream emits.
/// Note: Simplified implementation - takes all values from source for now.
/// A full implementation would require more complex concurrency handling.
/// </summary>
let untilStream (_stop: AsyncSeq<'TStop>) (source: AsyncSeq<'T>) : AsyncSeq<'T> =
  // Simplified: just emit all values from source
  // Full implementation would stop when _stop emits
  source
// unnamed ends here

// [[file:index.org::17072]]
/// <summary>
/// Emits values from source only after start stream emits.
/// </summary>
let sinceStream (start: AsyncSeq<'TStart>) (source: AsyncSeq<'T>) : AsyncSeq<'T> =
  asyncSeq {
    // Wait for start signal
    for _ in start do
      ()
    
    // Now emit all values
    for item in source do
      yield item
  }
// unnamed ends here

// [[file:index.org::17426]]
/// <summary>
/// Collects values into lists of the specified size.
/// </summary>
let buffer' (size: int) (source: AsyncSeq<'T>) : AsyncSeq<List<'T>> =
  asyncSeq {
    let buf = ResizeArray<'T>()
    for item in source do
      buf.Add(item)
      if buf.Count >= size then
        yield List.ofSeq buf
        buf.Clear()
    if buf.Count > 0 then
      yield List.ofSeq buf
  }
// unnamed ends here

// [[file:index.org::17813]]
/// <summary>
/// Collects values over time windows (simplified).
/// </summary>
let bufferTime (ms: int) (source: AsyncSeq<'T>) : AsyncSeq<List<'T>> =
  asyncSeq {
    let buf = ResizeArray<'T>()
    for item in source do
      buf.Add(item)
      // Simplified: emit on each item (true time-based would need timer)
      do! Async.Sleep(ms)
      if buf.Count > 0 then
        yield List.ofSeq buf
        buf.Clear()
  }
// unnamed ends here

// [[file:index.org::18233]]
/// <summary>
/// Splits source into windows of specified size.
/// </summary>
let window (size: int) (source: AsyncSeq<'T>) : AsyncSeq<List<'T>> =
  buffer' size source
// unnamed ends here

// [[file:index.org::18769]]
/// <summary>
/// Pre-fetches values from source (simplified).
/// Note: AsyncSeq is lazy by default, caching provides buffering.
/// </summary>
let eager (bufferSize: int) (source: AsyncSeq<'T>) : AsyncSeq<'T> =
  AsyncSeq.cache source

/// <summary>
/// Pre-fetches immediately (simplified to cache).
/// </summary>
let eagerNow (bufferSize: int) (source: AsyncSeq<'T>) : AsyncSeq<'T> =
  AsyncSeq.cache source
// unnamed ends here

// [[file:index.org::19877]]
/// <summary>
/// A multicasting subject that replays buffered values to new subscribers.
/// Simplified implementation using MailboxProcessor.
/// </summary>
type ReplaySubject<'T>(bufferSize: int) =
  let mutable buffer = ResizeArray<'T>()
  let mutable subscribers = ResizeArray<'T -> unit>()
  let mutable completed = false
  
  member this.Next(value: 'T) =
    if completed then
      failwith "Cannot push to completed ReplaySubject"
    buffer.Add(value)
    if buffer.Count > bufferSize then
      buffer.RemoveAt(0)
    for sub in subscribers do
      sub value
  
  member this.Complete() =
    completed <- true
  
  member this.Subscribe() : AsyncSeq<'T> =
    asyncSeq {
      // Replay buffered values
      for value in buffer do
        yield value
      
      // Note: Live value subscription would require more complex coordination
      // This simplified version only replays buffer
    }
  
  member this.GetBuffer() = List.ofSeq buffer
  
  member this.SubscriberCount = subscribers.Count
// unnamed ends here

// [[file:index.org::20236]]
/// <summary>
/// Creates a replay wrapper for a stream (simplified).
/// </summary>
let replay (bufferSize: int) (source: AsyncSeq<'T>) : AsyncSeq<'T> =
  // Simplified: just cache the stream
  AsyncSeq.cache source

/// <summary>
/// Shares a stream without buffering (simplified).
/// </summary>
let share (source: AsyncSeq<'T>) : AsyncSeq<'T> =
  AsyncSeq.cache source
// unnamed ends here

// [[file:index.org::20582]]
/// <summary>
/// Creates a factory that produces independent copies of a buffered stream.
/// </summary>
let replayFactory (bufferSize: int) (source: AsyncSeq<'T>) : unit -> AsyncSeq<'T> =
  let cached = AsyncSeq.cache source
  fun () -> cached
// unnamed ends here
