// This file is auto-generated by organjsm tangle. Do not edit directly.
// Source: index.org

// [[file:index.org::747]]
namespace AgentRex.Tests

open Xunit
open FSharp.Control
open AgentRex.Stream

module JustTests =
  [<Fact>]
  let ``just emits single value and completes`` () =
      async {
          let! values = just 42 |> AsyncSeq.toListAsync
          Assert.Equal<int list>([42], values)
      } |> Async.RunSynchronously
  
  [<Fact>]
  let ``of is alias for just`` () =
      async {
          let! values = of' "hello" |> AsyncSeq.toListAsync
          Assert.Equal<string list>(["hello"], values)
      } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::1174]]
module FromAsyncTests =
  [<Fact>]
  let ``fromAsync emits resolved value`` () =
    async {
      let computation = async { return 42 }
      let! values = fromAsync computation |> AsyncSeq.toListAsync
      Assert.Equal<int list>([42], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``fromTask emits task result`` () =
    async {
      let task = System.Threading.Tasks.Task.FromResult("result")
      let! values = fromTask task |> AsyncSeq.toListAsync
      Assert.Equal<string list>(["result"], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::1515]]
module FromTests =
  [<Fact>]
  let ``fromSeq emits all values`` () =
    async {
      let! values = fromSeq [1; 2; 3] |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``fromList handles empty list`` () =
    async {
      let! values = fromList ([] : int list) |> AsyncSeq.toListAsync
      Assert.Equal<int list>([], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``fromArray works with arrays`` () =
    async {
      let! values = fromArray [|4; 5; 6|] |> AsyncSeq.toListAsync
      Assert.Equal<int list>([4; 5; 6], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::1839]]
module PeriodicTests =
  [<Fact>]
  let ``periodic emits at intervals`` () =
    async {
      let! values = 
        periodic 10 
        |> AsyncSeq.take 3 
        |> AsyncSeq.toListAsync
      Assert.Equal(3, values.Length)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::2069]]
module EmptyTests =
  [<Fact>]
  let ``empty completes immediately`` () =
    async {
      let! values = empty<int>() |> AsyncSeq.toListAsync
      Assert.Equal<int list>([], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::2315]]
module NeverTests =
  [<Fact>]
  let ``never does not complete`` () =
    // Test that never doesn't complete within timeout
    use cts = new System.Threading.CancellationTokenSource(50)
    let computation = async {
      let! _ = never<int>() |> AsyncSeq.toListAsync
      return true
    }
    try
      Async.RunSynchronously(computation, cancellationToken = cts.Token)
      failwith "Should not complete"
    with
    | :? System.OperationCanceledException -> () // Expected - timeout
// unnamed ends here

// [[file:index.org::2614]]
module IterateTests =
  [<Fact>]
  let ``iterate generates sequence`` () =
    async {
      let! values = 
        iterate 1 (fun x -> x * 2) 
        |> AsyncSeq.take 5 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 4; 8; 16], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``iterate with addition`` () =
    async {
      let! values = 
        iterate 0 (fun x -> x + 1) 
        |> AsyncSeq.take 4 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([0; 1; 2; 3], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::3058]]
module UnfoldTests =
  
  [<Fact>]
  let ``unfold generates values until done`` () =
    async {
      let! values = 
        unfold (fun n -> {
          Value = n
          NextSeed = n + 1
          Done = n > 3
        }) 1
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``unfold stops immediately when done`` () =
    async {
      let! values = 
        unfold (fun _ -> {
          Value = 999
          NextSeed = 0
          Done = true
        }) 0
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::3383]]
module StartWithTests =
  
  [<Fact>]
  let ``startWith prepends value`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3]
        |> startWith 0
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([0; 1; 2; 3], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``startWith works with empty stream`` () =
    async {
      let! values = 
        (empty ())
        |> startWith 42
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([42], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::3753]]
module ConcatTests =
  
  [<Fact>]
  let ``concat joins streams`` () =
    async {
      let! values = 
        concat2 (fromSeq [1; 2]) (fromSeq [3; 4])
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3; 4], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``concat with empty first`` () =
    async {
      let! values = 
        concat2 (empty ()) (fromSeq [5; 6])
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([5; 6], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``concat multiple streams`` () =
    async {
      let! values = 
        concat [fromSeq [1]; fromSeq [2; 3]; fromSeq [4]]
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3; 4], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::4630]]
module MapTests =
    
  [<Fact>]
  let ``map transforms values`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3] 
        |> map (fun x -> x * 2) 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([2; 4; 6], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``mapAsync with async function`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3] 
        |> mapAsync (fun x -> async {
            do! Async.Sleep 1
            return x * 10
        }) 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([10; 20; 30], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::4983]]
module ConstantTests =
  
  [<Fact>]
  let ``constant replaces all values`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3] 
        |> constant "x" 
        |> AsyncSeq.toListAsync
      Assert.Equal<string list>(["x"; "x"; "x"], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``constant empty stream`` () =
    async {
      let! values = 
        fromSeq [] 
        |> constant 42 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::5375]]
module ScanTests =
  
  [<Fact>]
  let ``scan accumulates with seed`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3] 
        |> scan (fun acc x -> acc + x) 0 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([0; 1; 3; 6], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``scan product`` () =
    async {
      let! values = 
        fromSeq [2; 3; 4] 
        |> scan (fun acc x -> acc * x) 1 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 6; 24], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``scan empty stream`` () =
    async {
      let! values = 
        fromSeq [] 
        |> scan (fun acc x -> acc + x) 100 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([100], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::5741]]
module TapTests =
  
  [<Fact>]
  let ``tap performs side effect`` () =
    async {
      let sideEffects = ResizeArray<int>()
      let! values = 
        fromSeq [1; 2; 3]
        |> tap (fun x -> sideEffects.Add(x))
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3], values)
      Assert.Equal<int list>([1; 2; 3], sideEffects |> List.ofSeq)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::6065]]
module AwaitTapTests =
  
  [<Fact>]
  let ``awaitTap awaits side effect`` () =
    async {
      let sideEffects = ResizeArray<int>()
      let! values = 
        fromSeq [1; 2; 3]
        |> awaitTap (fun x -> async {
          do! Async.Sleep 5
          sideEffects.Add(x)
        })
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3], values)
      Assert.Equal<int list>([1; 2; 3], sideEffects |> List.ofSeq)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::6439]]
module ContinueWithTests =
  
  [<Fact>]
  let ``continueWith appends stream`` () =
    async {
      let! values = 
        fromSeq [1; 2]
        |> continueWith (fun () -> fromSeq [3; 4])
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3; 4], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``continueWith is lazy`` () =
    async {
      let mutable called = false
      let! values = 
        fromSeq [1]
        |> continueWith (fun () ->
          called <- true
          fromSeq [99]
        )
        |> AsyncSeq.toListAsync
      Assert.True(called)
      Assert.Equal<int list>([1; 99], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::6752]]
module ConcatAllTests =
  
  [<Fact>]
  let ``concatAll flattens stream of streams`` () =
    async {
      let streamOfStreams = 
        asyncSeq {
          yield fromSeq [1; 2]
          yield fromSeq [3; 4]
        }
      let! values = 
        concatAll streamOfStreams
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3; 4], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::7094]]
module ConcatMapTests =
  
  [<Fact>]
  let ``concatMap maps and concatenates`` () =
    async {
      let! values = 
        fromSeq [1; 2]
        |> concatMap (fun x -> fromSeq [x * 10; x * 10 + 1])
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([10; 11; 20; 21], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``concatMap handles empty results`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3]
        |> concatMap (fun x -> if x > 1 then fromSeq [x] else (empty ()))
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([2; 3], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::7513]]
module FilterTests =
    
    [<Fact>]
    let ``filter keeps matching values`` () =
        async {
            let! values = 
                fromSeq [1; 2; 3; 4; 5] 
                |> filter (fun x -> x > 2) 
                |> AsyncSeq.toListAsync
            Assert.Equal<int list>([3; 4; 5], values)
        } |> Async.RunSynchronously
    
    [<Fact>]
    let ``filter even numbers`` () =
        async {
            let! values = 
                fromSeq [1; 2; 3; 4; 5; 6] 
                |> filter (fun x -> x % 2 = 0) 
                |> AsyncSeq.toListAsync
            Assert.Equal<int list>([2; 4; 6], values)
        } |> Async.RunSynchronously
    
    [<Fact>]
    let ``filterAsync with async predicate`` () =
        async {
            let! values = 
                fromSeq [1; 2; 3; 4] 
                |> filterAsync (fun x -> async {
                    do! Async.Sleep 1
                    return x % 2 = 0
                }) 
                |> AsyncSeq.toListAsync
            Assert.Equal<int list>([2; 4], values)
        } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::8107]]
module SkipRepeatsTests =
  
  [<Fact>]
  let ``skipRepeats removes consecutive duplicates`` () =
    async {
      let! values = 
        fromSeq [1; 1; 2; 2; 3; 1; 1]
        |> skipRepeats
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3; 1], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``skipRepeats handles single value`` () =
    async {
      let! values = 
        fromSeq [42]
        |> skipRepeats
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([42], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``skipRepeatsWith uses custom equality`` () =
    async {
      let! values = 
        fromSeq ["A"; "a"; "B"; "b"]
        |> skipRepeatsWith (fun a b -> a.ToLower() = b.ToLower())
        |> AsyncSeq.toListAsync
      Assert.Equal<string list>(["A"; "B"], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::8503]]
module TakeTests =
  [<Fact>]
  let ``take first n values`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3; 4; 5] 
        |> take 2 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``take more than available`` () =
    async {
      let! values = 
        fromSeq [1; 2] 
        |> take 10 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``take zero`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3] 
        |> take 0 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::8838]]
module SkipTests =
  
  [<Fact>]
  let ``skip first n values`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3; 4; 5] 
        |> skip 2 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([3; 4; 5], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``skip zero`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3] 
        |> skip 0 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``skip more than available`` () =
    async {
      let! values = 
        fromSeq [1; 2] 
        |> skip 5 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::9226]]
module SliceTests =
  
  [<Fact>]
  let ``slice extracts range`` () =
    async {
      let! values = 
        fromSeq [0; 1; 2; 3; 4; 5]
        |> slice 2 5
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([2; 3; 4], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``slice empty range`` () =
    async {
      let! values = 
        fromSeq [0; 1; 2; 3; 4]
        |> slice 2 2
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``slice beyond length`` () =
    async {
      let! values = 
        fromSeq [0; 1; 2]
        |> slice 1 10
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::9615]]
module TakeWhileTests =
  
  [<Fact>]
  let ``takeWhile takes while true`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3; 4; 2; 1]
        |> takeWhile (fun x -> x < 4)
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``takeWhile all pass`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3]
        |> takeWhile (fun _ -> true)
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``takeWhile none pass`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3]
        |> takeWhile (fun _ -> false)
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::10012]]
module SkipWhileTests =
  
  [<Fact>]
  let ``skipWhile skips while true`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3; 4; 2; 1]
        |> skipWhile (fun x -> x < 3)
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([3; 4; 2; 1], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``skipWhile all fail`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3]
        |> skipWhile (fun _ -> false)
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``skipWhile all pass`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3]
        |> skipWhile (fun _ -> true)
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::10403]]
module TakeUntilTests =
  
  [<Fact>]
  let ``takeUntil takes until match`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3; 4; 5]
        |> takeUntil (fun x -> x = 3)
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``takeUntil never matches`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3]
        |> takeUntil (fun _ -> false)
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``takeUntil first matches`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3]
        |> takeUntil (fun x -> x = 1)
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::10836]]
module DelayTests =
  
  [<Fact>]
  let ``delay delays each emission`` () =
    async {
      let sw = System.Diagnostics.Stopwatch.StartNew()
      let! values = 
        fromSeq [1; 2; 3] 
        |> delayEach 20 
        |> AsyncSeq.toListAsync
      sw.Stop()
      Assert.Equal<int list>([1; 2; 3], values)
      Assert.True(sw.ElapsedMilliseconds >= 50L) // ~60ms for 3 items
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``delay empty stream`` () =
    async {
      let! values = 
        fromSeq ([] : int list)
        |> delayEach 100 
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::11347]]
module DebounceTests =
  
  [<Fact>]
  let ``debounce emits only settled values`` () =
    async {
      let source = asyncSeq {
        yield 1
        do! Async.Sleep 10
        yield 2
        do! Async.Sleep 10
        yield 3
        do! Async.Sleep 50 // Let it settle
      }
      
      let! values = source |> debounceEach 30 |> AsyncSeq.toListAsync
      // Only the last value should be emitted
      Assert.Equal<int list>([3], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``debounce with large gaps emits multiple values`` () =
    async {
      let source = asyncSeq {
        yield 1
        do! Async.Sleep 50
        yield 2
      }
      
      let! values = source |> debounceEach 20 |> AsyncSeq.toListAsync
      // Both should emit since delay > debounce time
      Assert.Equal<int list>([1; 2], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::12038]]
module ThrottleTests =
  
  [<Fact>]
  let ``throttle leading emits first value`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3; 4; 5]
        |> throttleEach 100 ThrottleOptions.LeadingOnly
        |> AsyncSeq.toListAsync
      // First value should be emitted immediately
      Assert.NotEmpty(values)
      Assert.Equal(1, values.[0])
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``throttle trailing emits last value`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3]
        |> throttleEach 100 ThrottleOptions.TrailingOnly
        |> AsyncSeq.toListAsync
      // Last value should be emitted as trailing
      Assert.NotEmpty(values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``throttle empty stream`` () =
    async {
      let! values = 
        fromSeq ([] : int list)
        |> throttleEach 100 ThrottleOptions.Default
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::12589]]
module RecoverWithTests =
  
  [<Fact>]
  let ``recoverWith recovers from error`` () =
    async {
      let failing = asyncSeq {
        yield 1
        failwith "oops"
      }
      
      let! values = 
        failing
        |> recoverWith (fun _ -> fromSeq [99])
        |> AsyncSeq.toListAsync
      
      Assert.Equal<int list>([1; 99], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``recoverWith passes through success`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3]
        |> recoverWith (fun _ -> fromSeq [99])
        |> AsyncSeq.toListAsync
      
      Assert.Equal<int list>([1; 2; 3], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::13061]]
module ThrowErrorTests =
  
  [<Fact>]
  let ``throwError creates failing stream`` () =
    let error = System.InvalidOperationException("test error")
    Assert.Throws<System.InvalidOperationException>(fun () ->
      throwError<int> error
      |> AsyncSeq.toListAsync
      |> Async.RunSynchronously
      |> ignore
    ) |> ignore
// unnamed ends here

// [[file:index.org::13748]]
module RetryTests =
  
  [<Fact>]
  let ``retry retries until success`` () =
    async {
      let mutable attempts = 0
      
      let! values = 
        retry { MaxAttempts = 3; DelayMs = 0; ShouldRetry = None } (fun () ->
          asyncSeq {
            attempts <- attempts + 1
            if attempts < 3 then
              failwith $"fail {attempts}"
            yield attempts
          }
        ) |> AsyncSeq.toListAsync
      
      Assert.Equal(3, attempts)
      Assert.Equal<int list>([3], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``retry throws after max attempts`` () =
    let mutable attempts = 0
    
    Assert.Throws<System.Exception>(fun () ->
      retry { MaxAttempts = 2; DelayMs = 0; ShouldRetry = None } (fun () ->
        asyncSeq {
          attempts <- attempts + 1
          failwith "always fails"
        }
      ) |> AsyncSeq.toListAsync
      |> Async.RunSynchronously
      |> ignore
    ) |> ignore
    
    Assert.Equal(2, attempts)
// unnamed ends here

// [[file:index.org::14329]]
module MergeTests =
  
  [<Fact>]
  let ``merge combines multiple streams`` () =
    async {
      let s1 = fromSeq [1; 3; 5]
      let s2 = fromSeq [2; 4; 6]
      let! values = merge [s1; s2] |> AsyncSeq.toListAsync
      // Order may vary, check all present
      Assert.Equal(6, values.Length)
      Assert.Contains(1, values)
      Assert.Contains(6, values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``merge2 combines two streams`` () =
    async {
      let! values = merge2 (fromSeq [1; 2]) (fromSeq [3; 4]) |> AsyncSeq.toListAsync
      Assert.Equal(4, values.Length)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::14710]]
module MergeAllTests =
  
  [<Fact>]
  let ``mergeAll flattens stream of streams`` () =
    async {
      let streamOfStreams = asyncSeq {
        yield fromSeq [1; 2]
        yield fromSeq [3; 4]
      }
      
      let! values = mergeAll streamOfStreams |> AsyncSeq.toListAsync
      let sorted = values |> List.sort
      Assert.Equal<int list>([1; 2; 3; 4], sorted)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``mergeAll handles empty outer stream`` () =
    async {
      let streamOfStreams: AsyncSeq<AsyncSeq<int>> = asyncSeq { () }
      let! values = mergeAll streamOfStreams |> AsyncSeq.toListAsync
      Assert.Equal<int list>([], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::15152]]
module ChainTests =
  
  [<Fact>]
  let ``chain flattens inner streams`` () =
    async {
      let! values = 
        fromSeq [1; 2] 
        |> chain (fun x -> fromSeq [x * 10; x * 10 + 1]) 
        |> AsyncSeq.toListAsync
      let valueSet = Set.ofList values
      Assert.True(valueSet.Contains(10))
      Assert.True(valueSet.Contains(11))
      Assert.True(valueSet.Contains(20))
      Assert.True(valueSet.Contains(21))
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``flatMap is alias for chain`` () =
    async {
      let! values = 
        fromSeq [1; 2] 
        |> flatMap (fun x -> fromSeq [x; x * 2]) 
        |> AsyncSeq.toListAsync
      Assert.Equal(4, values.Length)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::15646]]
module SwitchMapTests =
  
  [<Fact>]
  let ``switchMap cancels previous inner stream`` () =
    async {
      let! values = 
        fromSeq [1; 2; 3]
        |> switchMap (fun x -> fromSeq [x * 10])
        |> AsyncSeq.toListAsync
      // With synchronous streams, may see all values
      Assert.NotEmpty(values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``switchMap completes when outer and inner complete`` () =
    async {
      let! values = 
        fromSeq [1]
        |> switchMap (fun x -> fromSeq [x; x * 2])
        |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::16086]]
module LatestTests =
  
  [<Fact>]
  let ``latest combines two streams`` () =
    async {
      let s1 = fromSeq [1; 2]
      let s2 = fromSeq ["a"; "b"]
      let! values = latest2 s1 s2 |> AsyncSeq.toListAsync
      // Should emit tuples
      Assert.NotEmpty(values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::16352]]
module ApplyLatestTests =
  
  [<Fact>]
  let ``applyLatest applies function to value`` () =
    async {
      let fns = fromSeq [(fun x -> x * 2); (fun x -> x * 3)]
      let vals = fromSeq [10; 20]
      let! values = applyLatest fns vals |> AsyncSeq.toListAsync
      Assert.NotEmpty(values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::16731]]
module UntilStreamTests =
  
  [<Fact>]
  let ``untilStream stops when stop emits`` () =
    async {
      let source = fromSeq [1; 2; 3; 4; 5]
      let stop = fromSeq [()]
      let! values = untilStream stop source |> AsyncSeq.toListAsync
      Assert.True(values.Length <= 5)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::17100]]
module SinceStreamTests =
  
  [<Fact>]
  let ``sinceStream waits for start`` () =
    async {
      let source = fromSeq [1; 2; 3; 4]
      let start = fromSeq [()]
      let! values = sinceStream start source |> AsyncSeq.toListAsync
      Assert.NotEmpty(values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::17452]]
module BufferTests =
  
  [<Fact>]
  let ``buffer collects into fixed-size lists`` () =
    async {
      let source = fromSeq [1; 2; 3; 4; 5]
      let! values = buffer' 2 source |> AsyncSeq.toListAsync
      Assert.Equal(3, values.Length)
      Assert.Equal<int list>([1; 2], values.[0])
      Assert.Equal<int list>([3; 4], values.[1])
      Assert.Equal<int list>([5], values.[2])
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::17839]]
module BufferTimeTests =
  
  [<Fact>]
  let ``bufferTime collects over time`` () =
    async {
      let source = fromSeq [1; 2; 3]
      let! values = bufferTime 100 source |> AsyncSeq.toListAsync
      Assert.NotEmpty(values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::18250]]
module WindowTests =
  
  [<Fact>]
  let ``window splits into fixed-size groups`` () =
    async {
      let source = fromSeq [1; 2; 3; 4; 5]
      let! values = window 2 source |> AsyncSeq.toListAsync
      Assert.Equal(3, values.Length)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::18793]]
module EagerTests =
  
  [<Fact>]
  let ``eager prefetches values`` () =
    async {
      let source = fromSeq [1; 2; 3]
      let! values = eager 2 source |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::19923]]
module ReplaySubjectTests =
  
  [<Fact>]
  let ``ReplaySubject replays buffered values`` () =
    async {
      let subject = ReplaySubject<int>(2)
      subject.Next(1)
      subject.Next(2)
      subject.Next(3)
      subject.Complete()
      
      let! values = subject.Subscribe() |> AsyncSeq.toListAsync
      // Should get last 2 values (2, 3)
      Assert.Contains(2, values)
      Assert.Contains(3, values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::20260]]
module ReplayTests =
  
  [<Fact>]
  let ``replay multicasts with buffer`` () =
    async {
      let source = fromSeq [1; 2; 3]
      let replayed = replay 2 source
      let! values = replayed |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3], values)
    } |> Async.RunSynchronously
  
  [<Fact>]
  let ``share multicasts without buffer`` () =
    async {
      let source = fromSeq [1; 2; 3]
      let shared = share source
      let! values = shared |> AsyncSeq.toListAsync
      Assert.Equal<int list>([1; 2; 3], values)
    } |> Async.RunSynchronously
// unnamed ends here

// [[file:index.org::20600]]
module ReplayFactoryTests =
  
  [<Fact>]
  let ``replayFactory creates stream copies`` () =
    async {
      let factory = replayFactory 2 (fromSeq [1; 2; 3])
      
      let! copy1 = factory() |> AsyncSeq.toListAsync
      let! copy2 = factory() |> AsyncSeq.toListAsync
      
      Assert.NotEmpty(copy1)
      Assert.NotEmpty(copy2)
    } |> Async.RunSynchronously
// unnamed ends here
